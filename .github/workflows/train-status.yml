name: Train Status (RTT)

on:
  schedule:
    # Run every 5 mins between 05:25–06:20 UTC on weekdays; gate to 06:30–07:15 Europe/London inside the job.
    - cron: "*/5 5-6 * * 1-5"
  workflow_dispatch:
    inputs:
      force:
        description: "Bypass time gate (run now at any time)"
        required: false
        default: "false"

jobs:
  fetch:
    runs-on: ubuntu-latest
    env:
      # --- CONFIG ---
      ORIGIN_CRS: "STE"       # Streatham
      DEST_CRS: "WIM"         # Wimbledon
      BOOKED_DEPART_HHMM: "0744"
      LONDON_TZ: "Europe/London"
      # Time window (local) in which the job is allowed to run automatically
      START_LOCAL_TIME: "06:30"
      END_LOCAL_TIME:   "07:15"
      # ---------------
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Create fetch script
        run: |
          mkdir -p scripts
          cat > scripts/fetch_rtt.js <<'EOF'
          import fs from 'fs';

          const USER = process.env.RTT_USERNAME;
          const PASS = process.env.RTT_PASSWORD;
          const ORIGIN = process.env.ORIGIN_CRS;
          const DEST = process.env.DEST_CRS;
          const GBTT = process.env.BOOKED_DEPART_HHMM; // "0744"
          const LONDON_TZ = process.env.LONDON_TZ || "Europe/London";

          function pad(n){ return String(n).padStart(2,'0'); }

          // Build a Date representing "now" in Europe/London for consistent day selection
          const now = new Date();
          // Format local time parts
          const localParts = new Intl.DateTimeFormat('en-GB', {
            timeZone: LONDON_TZ,
            year: 'numeric', month: '2-digit', day: '2-digit',
            hour: '2-digit', minute: '2-digit', hour12: false
          }).formatToParts(now).reduce((acc,p)=> (acc[p.type]=p.value, acc), {});
          const yyyy = localParts.year;
          const mm   = localParts.month;
          const dd   = localParts.day;
          const dateStr = `${yyyy}/${mm}/${dd}`;
          const generatedAt = new Date(`${yyyy}-${mm}-${dd}T${localParts.hour}:${localParts.minute}:00`).toISOString();

          const b64 = Buffer.from(`${USER}:${PASS}`).toString('base64');
          const headers = { "Authorization": `Basic ${b64}`, "Accept": "application/json" };

          async function httpJson(url){
            const res = await fetch(url, { headers });
            if(!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText} for ${url}`);
            return res.json();
          }

          const hhmmToMinutes = s => parseInt(s.slice(0,2))*60 + parseInt(s.slice(2));
          const diffMinutes = (a,b) => hhmmToMinutes(a) - hhmmToMinutes(b);

          const findCall = (crs, service) => service?.locations?.find(l => l.crs === crs) || null;

          (async () => {
            try {
              if(!USER || !PASS) throw new Error("Missing RTT_USERNAME or RTT_PASSWORD env");

              const searchUrl = `https://api.rtt.io/api/v1/json/search/${ORIGIN}/${dateStr}/${GBTT}/to/${DEST}`;
              const search = await httpJson(searchUrl);

              const svc = (search?.services || []).find(s => {
                const ld = s.locationDetail;
                if(!ld) return false;
                const bookedDep = ld.gbttBookedDeparture;
                const dest = s?.destination?.[0]?.crs;
                return bookedDep === GBTT && dest === DEST;
              });

              if(!svc){
                const payload = {
                  generatedAt,
                  date: `${yyyy}-${mm}-${dd}`,
                  originCRS: ORIGIN,
                  destinationCRS: DEST,
                  gbttBookedDeparture: GBTT,
                  status: "not_found",
                  note: "Booked service not found at search time.",
                  searchUrl
                };
                fs.writeFileSync('status.json', JSON.stringify(payload, null, 2));
                fs.appendFileSync('history.jsonl', JSON.stringify(payload) + "\n");
                console.log("Saved status.json (not_found).");
                process.exit(0);
              }

              const { serviceUid, runDate } = svc;
              const detailUrl = `https://api.rtt.io/api/v1/json/service/${serviceUid}/${runDate}`;
              const detail = await httpJson(detailUrl);

              function callInfo(call){
                if(!call) return null;
                const bookedArr = call.gbttBookedArrival || null;
                const bookedDep = call.gbttBookedDeparture || null;
                const rtArr = call.realtimeArrival || null;
                const rtDep = call.realtimeDeparture || null;
                const arrDelay = (rtArr && bookedArr) ? diffMinutes(rtArr, bookedArr) : null;
                const depDelay = (rtDep && bookedDep) ? diffMinutes(rtDep, bookedDep) : null;
                return {
                  bookedArrival: bookedArr,
                  bookedDeparture: bookedDep,
                  realtimeArrival: rtArr,
                  realtimeDeparture: rtDep,
                  arrivalDelayMins: arrDelay,
                  departureDelayMins: depDelay,
                  platform: call.platform || null,
                  isCancelled: !!call.isCancelled,
                  cancelReasonCode: call.cancelReasonCode || null,
                  cancelReasonShortText: call.cancelReasonShortText || null
                };
              }

              const origin = callInfo(findCall(ORIGIN, detail));
              const dest   = callInfo(findCall(DEST, detail));

              let overall = "on_time";
              if(origin?.isCancelled || dest?.isCancelled) overall = "cancelled";
              else if((origin?.departureDelayMins ?? 0) > 0 || (dest?.arrivalDelayMins ?? 0) > 0) overall = "delayed";
              else if((origin?.departureDelayMins ?? 0) < 0 || (dest?.arrivalDelayMins ?? 0) < 0) overall = "early";

              const payload = {
                generatedAt,
                date: `${yyyy}-${mm}-${dd}`,
                serviceUid, runDate,
                originCRS: ORIGIN, destinationCRS: DEST,
                gbttBookedDeparture: GBTT,
                origin, destination: dest,
                status: overall,
                searchUrl, detailUrl
              };

              fs.writeFileSync('status.json', JSON.stringify(payload, null, 2));
              fs.appendFileSync('history.jsonl', JSON.stringify(payload) + "\n");
              console.log("Saved status.json");
            } catch (e){
              console.error(e);
              const msg = { error: String(e), when: new Date().toISOString() };
              fs.writeFileSync('status.json', JSON.stringify(msg, null, 2));
              fs.appendFileSync('history.jsonl', JSON.stringify(msg) + "\n");
              process.exit(0);
            }
          })();
          EOF

      - name: Time gate (Europe/London window or force)
        env:
          START: ${{ env.START_LOCAL_TIME }}
          END:   ${{ env.END_LOCAL_TIME }}
          LONDON_TZ: ${{ env.LONDON_TZ }}
          FORCE: ${{ github.event.inputs.force }}
        run: |
          if [ "${FORCE}" = "true" ]; then
            echo "Force run enabled; bypassing time gate."
            exit 0
          fi
          node -e '
            const tz = process.env.LONDON_TZ || "Europe/London";
            const start = process.env.START || "06:30";
            const end   = process.env.END   || "07:15";
            const now = new Date();
            const fmt = new Intl.DateTimeFormat("en-GB", { timeZone: tz, hour: "2-digit", minute: "2-digit", hour12: false });
            const hm = fmt.format(now); // "HH:MM"
            const toM = s => parseInt(s.slice(0,2))*60 + parseInt(s.slice(3,5));
            const cur = toM(hm), sM = toM(start), eM = toM(end);
            const allowed = (cur >= sM && cur <= eM);
            console.log(`Local time: ${hm} (${tz})  allowed window: ${start}-${end}  -> ${allowed}`);
            if(!allowed) process.exit(78);
          '

      - name: Fetch Realtime Trains + write files
        if: ${{ success() }}
        env:
          RTT_USERNAME: ${{ secrets.RTT_USERNAME }}
          RTT_PASSWORD: ${{ secrets.RTT_PASSWORD }}
          ORIGIN_CRS: ${{ env.ORIGIN_CRS }}
          DEST_CRS: ${{ env.DEST_CRS }}
          BOOKED_DEPART_HHMM: ${{ env.BOOKED_DEPART_HHMM }}
          LONDON_TZ: ${{ env.LONDON_TZ }}
        run: node scripts/fetch_rtt.js

      - name: Commit status.json
        if: ${{ success() }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add status.json history.jsonl
          git commit -m "Update train status snapshot" || echo "No changes"
          git push
