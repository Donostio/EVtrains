name: Train Status (RTT)

on:
  schedule:
    - cron: "*/5 5-6 * * 1-5"
  workflow_dispatch:
    inputs:
      force:
        description: "Bypass time gate (run now at any time)"
        required: false
        default: "false"

jobs:
  fetch:
    runs-on: ubuntu-latest
    env:
      ORIGIN_CRS: STE
      DEST_CRS: WIM
      BOOKED_DEPART_HHMM: "0744"
      LONDON_TZ: Europe/London
      START_LOCAL_TIME: "06:30"
      END_LOCAL_TIME: "07:15"
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Create fetch script
        run: |
          mkdir -p scripts
          cat > scripts/fetch_rtt.js <<'EOF'
// scripts/fetch_rtt.js (CommonJS)
const fs = require('fs');

const USER = process.env.RTT_USERNAME;
const PASS = process.env.RTT_PASSWORD;
const ORIGIN = process.env.ORIGIN_CRS || "STE";
const DEST = process.env.DEST_CRS || "WIM";
const GBTT = process.env.BOOKED_DEPART_HHMM || "0744";
const LONDON_TZ = process.env.LONDON_TZ || "Europe/London";

const pad = n => String(n).padStart(2,'0');
const hhmmToMinutes = s => parseInt(s.slice(0,2),10)*60 + parseInt(s.slice(2),10);
const diffMinutes = (a,b) => hhmmToMinutes(a) - hhmmToMinutes(b);

function getLocalParts(date = new Date(), tz = LONDON_TZ) {
  const parts = new Intl.DateTimeFormat('en-GB', {
    timeZone: tz,
    year: 'numeric', month: '2-digit', day: '2-digit',
    hour: '2-digit', minute: '2-digit', hour12: false
  }).formatToParts(date).reduce((acc,p)=> (acc[p.type]=p.value, acc), {});
  return parts;
}

// Rule: today until 17:00, then tomorrow
function chooseServiceDate() {
  const now = new Date();
  const lp = getLocalParts(now);
  let y = parseInt(lp.year,10), m = parseInt(lp.month,10), d = parseInt(lp.day,10);
  const hour = parseInt(lp.hour,10);
  if (hour >= 17) {
    const dt = new Date(Date.UTC(y, m-1, d, 12, 0, 0));
    dt.setUTCDate(dt.getUTCDate() + 1);
    const nlp = getLocalParts(dt);
    y = parseInt(nlp.year,10); m = parseInt(nlp.month,10); d = parseInt(nlp.day,10);
  }
  return { yyyy: String(y), mm: pad(m), dd: pad(d) };
}

const { yyyy, mm, dd } = chooseServiceDate();
const dateStr = `${yyyy}/${mm}/${dd}`;

const nowLP = getLocalParts();
const generatedAt = new Date(`${nowLP.year}-${nowLP.month}-${nowLP.day}T${nowLP.hour}:${nowLP.minute}:00`).toISOString();

const b64 = Buffer.from(`${USER}:${PASS}`).toString('base64');
const headers = { "Authorization": `Basic ${b64}`, "Accept": "application/json" };

async function httpJson(url){
  const res = await fetch(url, { headers });
  if(!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText} for ${url}`);
  return res.json();
}

const findCall = (crs, service) => service?.locations?.find(l => l.crs === crs) || null;

async function searchCandidates() {
  const filtered = `https://api.rtt.io/api/v1/json/search/${ORIGIN}/to/${DEST}/${dateStr}/${GBTT}`;
  try {
    const js = await httpJson(filtered);
    const svcs = (js?.services || []).filter(s => s?.locationDetail?.gbttBookedDeparture === GBTT);
    return { urlTried: filtered, services: svcs, filtered: true };
  } catch (e) {
    const unfiltered = `https://api.rtt.io/api/v1/json/search/${ORIGIN}/${dateStr}/${GBTT}`;
    const js = await httpJson(unfiltered);
    const svcs = (js?.services || []).filter(s => s?.locationDetail?.gbttBookedDeparture === GBTT);
    return { urlTried: unfiltered, services: svcs, filtered: false };
  }
}

(async () => {
  try {
    if(!USER || !PASS) throw new Error("Missing RTT_USERNAME or RTT_PASSWORD env");

    const { urlTried, services, filtered } = await searchCandidates();

    let chosen = null;
    if (filtered) {
      chosen = services.find(s => s?.destination?.[0]?.crs === DEST) || services[0] || null;
    } else {
      for (const s of services.slice(0, 5)) {
        const { serviceUid, runDate } = s || {};
        if (!serviceUid || !runDate) continue;
        const detailUrl = `https://api.rtt.io/api/v1/json/service/${serviceUid}/${runDate}`;
        try {
          const detail = await httpJson(detailUrl);
          if (findCall(DEST, detail)) { chosen = s; break; }
        } catch {}
      }
      if (!chosen) chosen = services[0] || null;
    }

    if(!chosen){
      const payload = {
        generatedAt,
        date: `${yyyy}-${mm}-${dd}`,
        originCRS: ORIGIN,
        destinationCRS: DEST,
        gbttBookedDeparture: GBTT,
        status: "not_found",
        note: "Booked service not found in search results.",
        searchUrl: urlTried
      };
      fs.writeFileSync('status.json', JSON.stringify(payload, null, 2));
      fs.appendFileSync('history.jsonl', JSON.stringify(payload) + "\n");
      console.log("Saved status.json (not_found).");
      process.exit(0);
    }

    const { serviceUid, runDate } = chosen;
    const detailUrl = `https://api.rtt.io/api/v1/json/service/${serviceUid}/${runDate}`;
    const detail = await httpJson(detailUrl);

    function callInfo(call){
      if(!call) return null;
      const bookedArr = call.gbttBookedArrival || null;
      const bookedDep = call.gbttBookedDeparture || null;
      const rtArr = call.realtimeArrival || null;
      const rtDep = call.realtimeDeparture || null;
      const arrDelay = (rtArr && bookedArr) ? diffMinutes(rtArr, bookedArr) : null;
      const depDelay = (rtDep && bookedDep) ? diffMinutes(rtDep, bookedDep) : null;
      return {
        bookedArrival: bookedArr,
        bookedDeparture: bookedDep,
        realtimeArrival: rtArr,
        realtimeDeparture: rtDep,
        arrivalDelayMins: arrDelay,
        departureDelayMins: depDelay,
        platform: call.platform || null,
        isCancelled: !!call.isCancelled,
        cancelReasonCode: call.cancelReasonCode || null,
        cancelReasonShortText: call.cancelReasonShortText || null
      };
    }

    const origin = callInfo(findCall(ORIGIN, detail));
    const dest = callInfo(findCall(DEST, detail));

    let overall = "on_time";
    if(origin?.isCancelled || dest?.isCancelled) overall = "cancelled";
    else if((origin?.departureDelayMins ?? 0) > 0 || (dest?.arrivalDelayMins ?? 0) > 0) overall = "delayed";
    else if((origin?.departureDelayMins ?? 0) < 0 || (dest?.arrivalDelayMins ?? 0) < 0) overall = "early";

    const payload = {
      generatedAt,
      date: `${yyyy}-${mm}-${dd}`,
      serviceUid, runDate,
      originCRS: ORIGIN, destinationCRS: DEST,
      gbttBookedDeparture: GBTT,
      origin, destination: dest,
      status: overall,
      searchUrl: filtered
        ? `https://api.rtt.io/api/v1/json/search/${ORIGIN}/to/${DEST}/${dateStr}/${GBTT}`
        : `https://api.rtt.io/api/v1/json/search/${ORIGIN}/${dateStr}/${GBTT}`,
      detailUrl
    };

    fs.writeFileSync('status.json', JSON.stringify(payload, null, 2));
    fs.appendFileSync('history.jsonl', JSON.stringify(payload) + "\n");
    console.log("Saved status.json");
  } catch (e){
    console.error(e);
    const msg = { error: String(e), when: new Date().toISOString() };
    fs.writeFileSync('status.json', JSON.stringify(msg, null, 2));
    fs.appendFileSync('history.jsonl', JSON.stringify(msg) + "\n");
    process.exit(0);
  }
})();
EOF

      - name: Time gate (Europe/London window or force)
        env:
          START: ${{ env.START_LOCAL_TIME }}
          END: ${{ env.END_LOCAL_TIME }}
          LONDON_TZ: ${{ env.LONDON_TZ }}
          FORCE: ${{ github.event.inputs.force }}
        run: |
          if [ "${FORCE}" = "true" ]; then
            echo "Force run enabled; bypassing time gate."
            exit 0
          fi
          node -e "const tz=process.env.LONDON_TZ||'Europe/London';const start=process.env.START||'06:30';const end=process.env.END||'07:15';const fmt=new Intl.DateTimeFormat('en-GB',{timeZone:tz,hour:'2-digit',minute:'2-digit',hour12:false});const hm=fmt.format(new Date());const toM=s=>parseInt(s.slice(0,2))*60+parseInt(s.slice(3,5));const cur=toM(hm),sM=toM(start),eM=toM(end);const ok=(cur>=sM&&cur<=eM);console.log('Local time:',hm,'(',tz,') window',start,'-',end,'->',ok);if(!ok)process.exit(78);"

      - name: Fetch Realtime Trains + write files
        if: ${{ success() }}
        env:
          RTT_USERNAME: ${{ secrets.RTT_USERNAME }}
          RTT_PASSWORD: ${{ secrets.RTT_PASSWORD }}
        run: node scripts/fetch_rtt.js

      - name: Commit status.json
        if: ${{ success() }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add status.json history.jsonl
          git commit -m "Update train status snapshot" || echo "No changes"
          git push
