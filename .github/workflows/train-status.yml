// scripts/fetch_rtt.js
import fs from 'fs';

// --- ENV ---
const USER = process.env.RTT_USERNAME;
const PASS = process.env.RTT_PASSWORD;
const ORIGIN = process.env.ORIGIN_CRS || "STE";
const DEST = process.env.DEST_CRS   || "WIM";
const GBTT = process.env.BOOKED_DEPART_HHMM || "0744"; // "HHmm"
const LONDON_TZ = process.env.LONDON_TZ || "Europe/London";

// --- helpers ---
const pad = n => String(n).padStart(2,'0');
const hhmmToMinutes = s => parseInt(s.slice(0,2))*60 + parseInt(s.slice(2),10);
const diffMinutes = (a,b) => hhmmToMinutes(a) - hhmmToMinutes(b);

function getLocalParts(date = new Date(), tz = LONDON_TZ) {
  return new Intl.DateTimeFormat('en-GB', {
    timeZone: tz,
    year: 'numeric', month: '2-digit', day: '2-digit',
    hour: '2-digit', minute: '2-digit', hour12: false
  }).formatToParts(date).reduce((acc,p)=> (acc[p.type]=p.value, acc), {});
}

/**
 * Date selection rule (per your request):
 * - From 00:00 up to 16:59 local → use **today** (today’s 07:44).
 * - From 17:00 onward           → use **tomorrow** (tomorrow’s 07:44).
 */
function chooseServiceDate() {
  const now = new Date();
  const lp = getLocalParts(now);
  const hour = parseInt(lp.hour, 10);

  let y = parseInt(lp.year,10), m = parseInt(lp.month,10), d = parseInt(lp.day,10);
  if (hour >= 17) {
    // roll to tomorrow (use UTC midday anchor to avoid DST edge cases)
    const dt = new Date(Date.UTC(y, m-1, d, 12, 0, 0));
    dt.setUTCDate(dt.getUTCDate() + 1);
    const nlp = getLocalParts(dt);
    y = parseInt(nlp.year,10); m = parseInt(nlp.month,10); d = parseInt(nlp.day,10);
  }
  return { yyyy: String(y), mm: pad(m), dd: pad(d) };
}

const { yyyy, mm, dd } = chooseServiceDate();
const dateStr = `${yyyy}/${mm}/${dd}`;
// generatedAt: local wall clock ISO
const localNow = getLocalParts();
const generatedAt = new Date(`${localNow.year}-${localNow.month}-${localNow.day}T${localNow.hour}:${localNow.minute}:00`).toISOString();

const b64 = Buffer.from(`${USER}:${PASS}`).toString('base64');
const headers = { "Authorization": `Basic ${b64}`, "Accept": "application/json" };

async function httpJson(url){
  const res = await fetch(url, { headers });
  if(!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText} for ${url}`);
  return res.json();
}

const findCall = (crs, service) => service?.locations?.find(l => l.crs === crs) || null;

// try filtered search first, then unfiltered as fallback
async function searchCandidates() {
  const filtered = `https://api.rtt.io/api/v1/json/search/${ORIGIN}/to/${DEST}/${dateStr}/${GBTT}`;
  try {
    const js = await httpJson(filtered);
    const svcs = (js?.services || []).filter(s => s?.locationDetail?.gbttBookedDeparture === GBTT);
    return { urlTried: filtered, services: svcs, filtered: true };
  } catch (e) {
    const unfiltered = `https://api.rtt.io/api/v1/json/search/${ORIGIN}/${dateStr}/${GBTT}`;
    const js = await httpJson(unfiltered);
    const svcs = (js?.services || []).filter(s => s?.locationDetail?.gbttBookedDeparture === GBTT);
    return { urlTried: unfiltered, services: svcs, filtered: false };
  }
}

(async () => {
  try {
    if(!USER || !PASS) throw new Error("Missing RTT_USERNAME or RTT_PASSWORD env");

    const { urlTried, services, filtered } = await searchCandidates();

    let chosen = null;
    if (filtered) {
      chosen = services.find(s => s?.destination?.[0]?.crs === DEST) || services[0] || null;
    } else {
      for (const s of services.slice(0, 5)) {
        const { serviceUid, runDate } = s || {};
        if (!serviceUid || !runDate) continue;
        const detailUrl = `https://api.rtt.io/api/v1/json/service/${serviceUid}/${runDate}`;
        try {
          const detail = await httpJson(detailUrl);
          if (findCall(DEST, detail)) { chosen = s; break; }
        } catch {}
      }
      if (!chosen) chosen = services[0] || null;
    }

    if(!chosen){
      const payload = {
        generatedAt,
        date: `${yyyy}-${mm}-${dd}`,
        originCRS: ORIGIN,
        destinationCRS: DEST,
        gbttBookedDeparture: GBTT,
        status: "not_found",
        note: "Booked service not found in search results.",
        searchUrl: urlTried
      };
      fs.writeFileSync('status.json', JSON.stringify(payload, null, 2));
      fs.appendFileSync('history.jsonl', JSON.stringify(payload) + "\n");
      console.log("Saved status.json (not_found).");
      process.exit(0);
    }

    const { serviceUid, runDate } = chosen;
    const detailUrl = `https://api.rtt.io/api/v1/json/service/${serviceUid}/${runDate}`;
    const detail = await httpJson(detailUrl);

    function callInfo(call){
      if(!call) return null;
      const bookedArr = call.gbttBookedArrival || null;
      const bookedDep = call.gbttBookedDeparture || null;
      const rtArr = call.realtimeArrival || null;
      const rtDep = call.realtimeDeparture || null;
      const arrDelay = (rtArr && bookedArr) ? diffMinutes(rtArr, bookedArr) : null;
      const depDelay = (rtDep && bookedDep) ? diffMinutes(rtDep, bookedDep) : null;
      return {
        bookedArrival: bookedArr,
        bookedDeparture: bookedDep,
        realtimeArrival: rtArr,
        realtimeDeparture: rtDep,
        arrivalDelayMins: arrDelay,
        departureDelayMins: depDelay,
        platform: call.platform || null,
        isCancelled: !!call.isCancelled,
        cancelReasonCode: call.cancelReasonCode || null,
        cancelReasonShortText: call.cancelReasonShortText || null
      };
    }

    const origin = callInfo(findCall(ORIGIN, detail));
    const dest   = callInfo(findCall(DEST, detail));

    let overall = "on_time";
    if(origin?.isCancelled || dest?.isCancelled) overall = "cancelled";
    else if((origin?.departureDelayMins ?? 0) > 0 || (dest?.arrivalDelayMins ?? 0) > 0) overall = "delayed";
    else if((origin?.departureDelayMins ?? 0) < 0 || (dest?.arrivalDelayMins ?? 0) < 0) overall = "early";

    const payload = {
      generatedAt,
      date: `${yyyy}-${mm}-${dd}`,
      serviceUid, runDate,
      originCRS: ORIGIN, destinationCRS: DEST,
      gbttBookedDeparture: GBTT,
      origin, destination: dest,
      status: overall,
      searchUrl: filtered
        ? `https://api.rtt.io/api/v1/json/search/${ORIGIN}/to/${DEST}/${dateStr}/${GBTT}`
        : `https://api.rtt.io/api/v1/json/search/${ORIGIN}/${dateStr}/${GBTT}`,
      detailUrl
    };

    fs.writeFileSync('status.json', JSON.stringify(payload, null, 2));
    fs.appendFileSync('history.jsonl', JSON.stringify(payload) + "\n");
    console.log("Saved status.json");
  } catch (e){
    console.error(e);
    const msg = { error: String(e), when: new Date().toISOString() };
    fs.writeFileSync('status.json', JSON.stringify(msg, null, 2));
    fs.appendFileSync('history.jsonl', JSON.stringify(msg) + "\n");
    process.exit(0);
  }
})();
