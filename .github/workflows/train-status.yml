name: Train Status (RTT)

on:
  schedule:
    # Run every 5 mins between 05:25–06:20 UTC on weekdays (Mon–Fri),
    # then gate by Europe/London time inside the job to hit the exact local times.
    - cron: "*/5 5-6 * * 1-5"
  workflow_dispatch: {}

jobs:
  fetch:
    runs-on: ubuntu-latest
    env:
      # --- CONFIG YOU CAN TWEAK ---
      ORIGIN_CRS: "STE"       # Streatham
      DEST_CRS: "WIM"         # Wimbledon
      BOOKED_DEPART_HHMM: "0744"
      LONDON_TZ: "Europe/London"
      # Allowed local times (HH:mm) to publish new snapshots
      ALLOWED_LOCAL_TIMES: "06:30,06:45,07:00,07:05,07:10,07:15"
      # -----------------------------
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install deps
        run: |
          mkdir -p scripts
          cat > scripts/fetch_rtt.js <<'EOF'
          import fs from 'fs';
          import path from 'path';

          const USER = process.env.RTT_USERNAME;
          const PASS = process.env.RTT_PASSWORD;
          const ORIGIN = process.env.ORIGIN_CRS;
          const DEST = process.env.DEST_CRS;
          const GBTT = process.env.BOOKED_DEPART_HHMM; // "0744"
          const LONDON_TZ = process.env.LONDON_TZ || "Europe/London";
          const NOW = new Date();
          const localNow = new Date(new Intl.DateTimeFormat('en-GB', {
            timeZone: LONDON_TZ,
            year: 'numeric', month: '2-digit', day: '2-digit',
            hour: '2-digit', minute: '2-digit', hour12: false
          }).format(NOW).replace(/(\d{2})\/(\d{2})\/(\d{4}),\s?(\d{2}):(\d{2})/, '$3-$2-$1T$4:$5:00'));

          function pad(n){ return String(n).padStart(2,'0'); }
          const yyyy = localNow.getFullYear();
          const mm = pad(localNow.getMonth()+1);
          const dd = pad(localNow.getDate());

          const dateStr = `${yyyy}/${mm}/${dd}`;
          const isoLocal = localNow.toISOString(); // still UTC stamp but derived from local components above

          const b64 = Buffer.from(`${USER}:${PASS}`).toString('base64');
          const headers = { "Authorization": `Basic ${b64}`, "Accept": "application/json" };

          async function httpJson(url){
            const res = await fetch(url, { headers });
            if(!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText} for ${url}`);
            return res.json();
          }

          function hhmmToMinutes(hhmm){
            const h = parseInt(hhmm.slice(0,2),10);
            const m = parseInt(hhmm.slice(2,4),10);
            return h*60+m;
          }

          function diffMinutes(aHHMM, bHHMM){
            // returns aHHMM - bHHMM in minutes
            return hhmmToMinutes(aHHMM) - hhmmToMinutes(bHHMM);
          }

          // Given a service JSON (from /service/...), find the Wimbledon call
          function findCallFor(crs, service){
            if(!service?.locations) return null;
            return service.locations.find(loc => loc.crs === crs);
          }

          (async () => {
            try {
              if(!USER || !PASS) throw new Error("Missing RTT_USERNAME or RTT_PASSWORD env");

              // 1) Search at booked time at origin → list of services near 07:44
              const searchUrl = `https://api.rtt.io/api/v1/json/search/${ORIGIN}/${dateStr}/` + GBTT + `/to/${DEST}`;
              const search = await httpJson(searchUrl);

              // heuristic: pick service matching booked dep 0744 and calling at DEST
              const svc = (search?.services || []).find(s => {
                const ld = s.locationDetail;
                if(!ld) return false;
                const bookedDep = ld.gbttBookedDeparture; // "0744"
                const dest = s?.destination?.[0]?.crs;
                return bookedDep === GBTT && dest === DEST;
              });

              if(!svc) {
                // No matching service found at booked time — could be cancelled pre-publication or timetable shift
                const payload = {
                  generatedAt: isoLocal,
                  date: `${yyyy}-${mm}-${dd}`,
                  origin: ORIGIN,
                  destination: DEST,
                  gbttBookedDeparture: GBTT,
                  status: "not_found",
                  note: "Booked 07:44 service not found in search results."
                };
                fs.writeFileSync('status.json', JSON.stringify(payload, null, 2));
                // append to history
                fs.appendFileSync('history.jsonl', JSON.stringify(payload) + "\n");
                console.log("Saved status.json (not_found).");
                process.exit(0);
              }

              const { serviceUid, runDate } = svc; // e.g. "G12345", "2025-10-08"
              // 2) Fetch full service to get arrival platform/time at WIM
              const detailUrl = `https://api.rtt.io/api/v1/json/service/${serviceUid}/${runDate}`;
              const detail = await httpJson(detailUrl);

              const originCall = findCallFor(ORIGIN, detail);
              const destCall   = findCallFor(DEST, detail);

              // Extract useful fields with sensible fallbacks
              function callInfo(call){
                if(!call) return null;
                const bookedArr = call.gbttBookedArrival || null;
                const bookedDep = call.gbttBookedDeparture || null;
                const rtArr = call.realtimeArrival || null;    // "hhmm" or null
                const rtDep = call.realtimeDeparture || null;  // "hhmm" or null
                const arrIsCancel = !!call.isCancelled && bookedArr;
                const depIsCancel = !!call.isCancelled && bookedDep;
                const plat = call.platform || null;

                const arrDelay = (rtArr && bookedArr) ? diffMinutes(rtArr, bookedArr) : null;
                const depDelay = (rtDep && bookedDep) ? diffMinutes(rtDep, bookedDep) : null;

                return {
                  bookedArrival: bookedArr,
                  bookedDeparture: bookedDep,
                  realtimeArrival: rtArr,
                  realtimeDeparture: rtDep,
                  arrivalDelayMins: arrDelay,
                  departureDelayMins: depDelay,
                  platform: plat,
                  isCancelled: !!call.isCancelled,
                  cancelReasonCode: call.cancelReasonCode || null,
                  cancelReasonShortText: call.cancelReasonShortText || null
                };
              }

              const origin = callInfo(originCall);
              const dest   = callInfo(destCall);

              let overallStatus = "on_time";
              if(origin?.isCancelled || dest?.isCancelled) overallStatus = "cancelled";
              else if((origin?.departureDelayMins ?? 0) > 0 || (dest?.arrivalDelayMins ?? 0) > 0) overallStatus = "delayed";
              else if((origin?.departureDelayMins ?? 0) < 0 || (dest?.arrivalDelayMins ?? 0) < 0) overallStatus = "early";

              const payload = {
                generatedAt: isoLocal,
                date: `${yyyy}-${mm}-${dd}`,
                serviceUid,
                runDate,
                originCRS: ORIGIN,
                destinationCRS: DEST,
                gbttBookedDeparture: GBTT,
                origin: origin || null,
                destination: dest || null,
                status: overallStatus,
                searchUrl, detailUrl
              };

              fs.writeFileSync('status.json', JSON.stringify(payload, null, 2));
              fs.appendFileSync('history.jsonl', JSON.stringify(payload) + "\n");
              console.log("Saved status.json");
            } catch (err){
              console.error(err);
              const msg = { error: String(err), when: new Date().toISOString() };
              fs.writeFileSync('status.json', JSON.stringify(msg, null, 2));
              fs.appendFileSync('history.jsonl', JSON.stringify(msg) + "\n");
              process.exit(0);
            }
          })();
          EOF

      - name: Time gate (keep exact Europe/London times)
        id: gate
        env:
          ALLOWED_LOCAL_TIMES: ${{ env.ALLOWED_LOCAL_TIMES }}
          LONDON_TZ: ${{ env.LONDON_TZ }}
        run: |
          node -e '
          const allowed = (process.env.ALLOWED_LOCAL_TIMES||"").split(",").map(s=>s.trim());
          const tz = process.env.LONDON_TZ || "Europe/London";
          const now = new Date();
          const fmt = new Intl.DateTimeFormat("en-GB", { timeZone: tz, hour: "2-digit", minute: "2-digit", hour12: false });
          const localHM = fmt.format(now); // "HH:MM"
          const hit = allowed.includes(localHM);
          console.log("Local time:", localHM, "allowed:", hit);
          if(!hit) process.exit(78); // neutral (skip)
          '

      - name: Fetch Realtime Trains + write files
        if: ${{ success() }}
        env:
          RTT_USERNAME: ${{ secrets.RTT_USERNAME }}
          RTT_PASSWORD: ${{ secrets.RTT_PASSWORD }}
          ORIGIN_CRS: ${{ env.ORIGIN_CRS }}
          DEST_CRS: ${{ env.DEST_CRS }}
          BOOKED_DEPART_HHMM: ${{ env.BOOKED_DEPART_HHMM }}
          LONDON_TZ: ${{ env.LONDON_TZ }}
        run: node scripts/fetch_rtt.js

      - name: Commit status.json
        if: ${{ success() }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add status.json history.jsonl
          git commit -m "Update train status snapshot" || echo "No changes"
          git push
